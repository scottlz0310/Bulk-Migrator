# 品質チェックリスト

## 新機能追加時の品質チェック手順

### 1. 設計フェーズ

#### 1.1 要件定義
- [ ] 機能要件が明確に定義されている
- [ ] 非機能要件（パフォーマンス、セキュリティ）が定義されている
- [ ] 品質要件（カバレッジ、エラー率）が定義されている
- [ ] 受入基準が EARS 形式で記述されている

#### 1.2 設計レビュー
- [ ] アーキテクチャ設計が既存システムと整合している
- [ ] セキュリティ考慮事項が検討されている
- [ ] エラーハンドリング戦略が定義されている
- [ ] テスト戦略が策定されている
- [ ] パフォーマンス要件が考慮されている

### 2. 実装フェーズ

#### 2.1 コード品質
- [ ] PEP 8 準拠のコードスタイル
- [ ] 適切な型ヒントの追加
- [ ] 関数・クラスに Docstring を記述
- [ ] 複雑な処理にコメントを追加
- [ ] 定数・設定値のハードコーディング回避

#### 2.2 リンティング・フォーマット
```bash
# 実行コマンド
uv run ruff check .
uv run ruff format .
uv run mypy src/
```

**チェック項目:**
- [ ] ruff チェックでエラー 0件
- [ ] コードフォーマットが統一されている
- [ ] mypy 型チェックでエラー 0件
- [ ] import 順序が統一されている

#### 2.3 セキュリティ
- [ ] 機密情報のハードコーディング回避
- [ ] 入力値の適切な検証・サニタイズ
- [ ] SQL インジェクション対策（該当する場合）
- [ ] 認証・認可の適切な実装
- [ ] ログ出力時の機密情報マスキング

```bash
# セキュリティスキャン実行
uv run python scripts/security_scan.py
```

### 3. テストフェーズ

#### 3.1 単体テスト
- [ ] 新規追加コードのテストカバレッジ 100%
- [ ] 正常系のテストケース作成
- [ ] 異常系のテストケース作成
- [ ] 境界値のテストケース作成
- [ ] モック・スタブの適切な使用

```bash
# テスト実行コマンド
uv run pytest tests/test_new_feature.py -v
uv run pytest --cov=src.new_feature --cov-report=html
```

#### 3.2 統合テスト
- [ ] 既存機能との連携テスト
- [ ] API 契約テスト（該当する場合）
- [ ] エラーハンドリングの統合テスト
- [ ] パフォーマンステスト

```bash
# 統合テスト実行
uv run pytest -m integration
```

#### 3.3 品質ゲート
**必須条件:**
- [ ] 全体テストカバレッジ 60% 以上維持
- [ ] 新規コードテストカバレッジ 80% 以上
- [ ] リンティングエラー 0件
- [ ] 型チェックエラー 0件
- [ ] セキュリティ脆弱性 0件
- [ ] 全テスト成功

### 4. ドキュメント

#### 4.1 コードドキュメント
- [ ] 関数・クラスの Docstring 記述
- [ ] 複雑なアルゴリズムのコメント
- [ ] 設定項目の説明
- [ ] API 仕様書の更新（該当する場合）

#### 4.2 ユーザードキュメント
- [ ] README.md の更新
- [ ] 使用方法の説明追加
- [ ] 設定例の追加
- [ ] トラブルシューティング情報の追加

### 5. リリース準備

#### 5.1 最終チェック
```bash
# 統合テスト実行
uv run python tests/integration_test.py

# 品質メトリクス確認
uv run python src/quality_metrics.py

# セキュリティスキャン
uv run python scripts/security_scan.py
```

#### 5.2 リリース判定
- [ ] 全ての品質ゲートを通過
- [ ] ステークホルダーの承認取得
- [ ] リリースノートの作成
- [ ] ロールバック計画の準備

## コードレビューチェックリスト

### 1. 機能性
- [ ] 要件を満たしている
- [ ] エッジケースが考慮されている
- [ ] エラーハンドリングが適切
- [ ] パフォーマンスが要件を満たしている

### 2. 可読性・保守性
- [ ] コードが理解しやすい
- [ ] 適切な変数・関数名
- [ ] 適切な関数・クラスの分割
- [ ] 重複コードの排除

### 3. セキュリティ
- [ ] 機密情報の適切な扱い
- [ ] 入力値検証の実装
- [ ] 権限チェックの実装
- [ ] ログ出力の安全性

### 4. テスト
- [ ] 十分なテストカバレッジ
- [ ] テストケースの品質
- [ ] テストの実行可能性
- [ ] テストの保守性

## 品質メトリクス閾値

### 1. コード品質
| メトリクス | 目標値 | 最低値 | 測定方法 |
|------------|--------|--------|----------|
| テストカバレッジ | 80% | 60% | pytest-cov |
| リンティングエラー | 0件 | 0件 | ruff |
| 型チェックエラー | 0件 | 5件 | mypy |
| 循環複雑度 | 10以下 | 15以下 | ruff C901 |

### 2. セキュリティ
| メトリクス | 目標値 | 最低値 | 測定方法 |
|------------|--------|--------|----------|
| セキュリティ脆弱性 | 0件 | 0件 | bandit |
| 機密情報漏洩 | 0件 | 0件 | 手動レビュー |

### 3. パフォーマンス
| メトリクス | 目標値 | 最低値 | 測定方法 |
|------------|--------|--------|----------|
| レスポンス時間 | 1秒以下 | 3秒以下 | パフォーマンステスト |
| メモリ使用量 | 100MB以下 | 200MB以下 | プロファイリング |

## 自動化チェック

### 1. pre-commit フック
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.1.6
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.7.1
    hooks:
      - id: mypy
        additional_dependencies: [types-requests]
```

### 2. CI/CD パイプライン
```yaml
# .github/workflows/quality-check.yml
name: Quality Check
on: [push, pull_request]

jobs:
  quality-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v1
      - run: uv sync
      - run: uv run ruff check .
      - run: uv run mypy src/
      - run: uv run pytest --cov=src --cov-fail-under=60
      - run: uv run python scripts/security_scan.py
```

## 品質改善アクション

### 1. カバレッジ向上
```bash
# 未カバー行の特定
uv run pytest --cov=src --cov-report=term-missing

# 特定モジュールの詳細確認
uv run pytest --cov=src.module_name --cov-report=html
```

### 2. リンティングエラー修正
```bash
# 自動修正可能なエラーの修正
uv run ruff check . --fix

# 手動修正が必要なエラーの確認
uv run ruff check . --no-fix
```

### 3. セキュリティ脆弱性対応
```bash
# 詳細なセキュリティレポート
uv run bandit -r src/ -f json -o security_report.json

# 特定の脆弱性の確認
uv run bandit -r src/ -ll
```

## まとめ

このチェックリストを活用することで、新機能追加時の品質を一定レベル以上に保つことができます。各フェーズでの適切なチェックにより、品質問題の早期発見と修正が可能になります。

定期的にこのチェックリストを見直し、プロジェクトの成長に合わせて更新することが重要です。
